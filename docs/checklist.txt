
Checklist when developing
-------------------------

Check:
+ updated change log (when tagging)
+ license file
+ license info in every source file
+ documentation in every source file
+ updated README.rst

--------------------------------------------------------------------------------------------------------------------

Check API design, according to Josh Bloch (see http://www.infoq.com/presentations/effective-api-design). Summarized:

Characteristics of good API:
+ APIs should be easy to learn, easy to use, hard to misuse, lead to easy to use and maintain client code, sufficiently powerful,
easy to extend, appropriate to audience

Process of API design:
+ write to the API early and often (and to SPI as well, if applicable), for example in test code

General principles:
+ API must do one thing, and do it well; good names drive development
+ when in doubt, leave it out; look for good power-to-weight ratio
+ implementation details should not leak into API
+ minimize accessibility of everything
+ names matter, and code should read like prose
+ documentation matters
+ document state space carefully (which becomes less of an issue with functional programming)
+ consider performance consequences of API design decisions (but do not optimize prematurely)
+ API must coexist peacefully with platform (JVM, JDK, Scala etc.)

Class design:
+ minimize mutability (which is obviously the case in a functional style of programming)
+ subclass only where it makes sense (IS-A relationship must hold), consider prohibiting inheritance where not designing for inheritance

Method design:
+ do not make the client do what the module could do
+ do not violate the principle of least astonishment
+ fail fast
+ provide programmatic access to all data available in String form
+ overload with care
+ use appropriate parameter and return types
+ use consistent parameter ordering across methods
+ avoid long parameter lists
+ avoid return values that demand exceptional processing

Exception design:
+ throw exceptions to indicate exceptional conditions
+ favor unchecked exceptions
+ include failure-capture information in exceptions

--------------------------------------------------------------------------------------------------------------------

Check use of Scala best practices:
+ code should be as functional as possible, so prefer immutability and side-effect-free functions
(or side-effects kept only inside functions), and think in expressions rather than statements;
I know from experience how the quality and robustness of the code improves as a result;
see also http://clojure.org/state
+ document immutability, e.g. with marker interface Immutable, and do not violate any promise of immutability
+ prefer Option over null

Check use of Maven best practices:
+ write pom.xml as documented in https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
+ do not use other Maven repositories (than Maven Central), whenever possible
+ clear unidirectional dependencies between Maven modules

Check use of Spring best practices:
+ dependencies between packages (and inside packages) unidirectional, and as obvious as possible
+ emulate Spring "templates" where appropriate, leaving resource management to "template", without taking away control from the user
of the API
+ programming against contracts is (still) good, especially at layer boundaries (also for testability)

Check API documentation:
+ use package objects, and document them (as overview of the package/namespace)

Check some other practices as well (where some of them apply more to applications than to libraries):
+ this should be obvious: software should just work (so a web application against a database should respect that database,
a web application should work as multi-user app, an XML parser should still be configurable, and a data processing library should be able
to handle larger data volumes)
+ so consider not using any abstractions that leak too much, no matter how popular they might be
+ when using frameworks, still remain in the driver seat (take charge of the architecture, choose what to use, how to use it, what not to use)
+ consider maintenance costs (of the software in production) when choosing an architecture; how hard are version migrations? how hard
is it to reason about the state of a stopped system?
+ when mixing Scala and Java, be explicit at boundaries between idiomatic Scala and idiomatic Java
+ choose layers wisely (if applicable), typically based on abstraction levels
+ less is often more: do you need multiple Maven modules? do you really need to implement Serializable (sometimes a hidden web framework cost)?
